package it.beije.ananke.reservation.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;

import javax.sql.DataSource;

@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth, DataSource dataSource)
            throws Exception {
        //Configure AuthenticationManager with jdbcAuthentication in order to
        //utilize mysql database for user's login.
        auth
                .jdbcAuthentication()
                //Datasource is a Spring autogenerated Bean that allows connection to db.
                //It takes its specs from src/main/resources/application.properties
                .dataSource(dataSource)
                //This option select the password Encoder to be used, it's also registered as
                //a Bean below so it can be autowired elsewhere in the code(see registration)
                .passwordEncoder(passwordEncoder())
                //Custom query so that Spring Security can retrive username(email), password
                //and enabled from the database and use it for authentication
                .usersByUsernameQuery(
                        "SELECT email, password, enabled FROM user WHERE email = ?")
                //Same as last one but for authorities
                .authoritiesByUsernameQuery(
                        "SELECT u.email, a.authority " +
                                "FROM user_authorities a NATURAL JOIN user u " +
                                "WHERE u.email = ? ");
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //Disabling Cross-Site-Request-Forgery.
        http.csrf().disable();

        //Returns the HttpSecurity for further customizations.
        //Also assert that we will be using a custom form for the login.
        //See documentation for the custom form's requirements
        http.formLogin()
                //Mapping the page that contains login-form
                .loginPage("/loginpage")
                //Url to be called from the front-end when the login-form submit
                //event happpens
                .loginProcessingUrl("/login")
                //form element's ids where security will find the username for the login
                .usernameParameter("email")
                //Same as above but for password
                .passwordParameter("password")
                //Custom class to be executed after a successfull login.
                //Go check that class for specs.
                .successHandler(getCustomAuthenticationSuccessHandler())
                //Default call after login failure, you can use the GET parameter to
                //send a custom error after failed login
                .failureUrl("/loginpage?error=true")
                .and()
                //Returns LogoutConfigurer for further config.
                //Default logout call is '/logout', see the docs for customization
                .logout()
                //Specify cookies to be deleted on logout
                .deleteCookies("JSESSIONID");

        //NOTE ::: ROLES =/= AUTHORIZATIONS, Spring security implements 2 similar but different concepts.
        //standard implementation -> role='ADMIN' , authorization='ROLE_ADMIN'
        //The database table contains the authorization, but here we work with roles.
        //Spring security converts them automatically but watch out

        //Here you can apply different authorizations for different users/parts of the web app
        http.authorizeRequests()

                //this is the admin-only section.
                //everything that comes under '/admin/', '/api/admin/', '/swagger-ui/', '/import'
                //is mapped as admin only zone
                .antMatchers("/admin/**").hasRole("ADMIN")
                .antMatchers("/api/admin/**").hasRole("ADMIN")
                .antMatchers("/swagger-ui/**").hasRole("ADMIN")
                .antMatchers("/import/**").hasRole("ADMIN")

                //this is the 'permit all', loginpage, register page and static content such as css/scripts/images
                .antMatchers("/loginpage").permitAll()
                .antMatchers("/register").permitAll()
                .antMatchers("/assets/**").permitAll()
                .antMatchers("/js/**").permitAll()
                .antMatchers("/images/**").permitAll()

                //Added support for email confirmation and password reset
                .antMatchers("/confirmRegistration/**").permitAll()
                .antMatchers("/resetPassword/**").permitAll()
                .antMatchers("/requestPasswordReset/**").permitAll()
                .antMatchers("/api/issue/sendIssue").permitAll()

                //Everything else needs at least the user to be authenticated. Since we have only 2
                //roles we can just ask for any authentication, since admin can of course access
                //everything
                .antMatchers("/**").authenticated();

        //this last line is a very handy line to uncommend when developing/debugging some functions
        //it allows to deactivate Spring Security so that you can test stuff without having
        //to login every time.
        //Comment every filter and uncomment this to activate it.
        //This obviously is debug-only and needs to be commented/removed
        //when done debugging/testing XD

        //.anyRequest().permitAll();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationSuccessHandler getCustomAuthenticationSuccessHandler() {
        return new CustomAuthenticationSuccessHandler();
    }
}